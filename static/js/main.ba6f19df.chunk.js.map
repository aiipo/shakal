{"version":3,"sources":["components/canvas/canvas.jsx","components/header/header.jsx","constants/routes.js","components/app/App.jsx","constants/core.js","reportWebVitals.js","index.jsx"],"names":["blazeface","require","Canvas","React","forwardRef","props","ref","canvasRef","useRef","modelRef","useState","faces","setFaces","canvasToImage","current","toDataURL","getDataFromImageData","images","Array","map","imageData","canvas","document","createElement","getContext","putImageData","prediction","image","a","estimateFaces","predictions","predictedFaces","length","i","topLeft","startX","startY","end","bottomRight","width","height","context","push","getImageData","fillStyle","fillRect","drawOnCanvas","drawImage","useEffect","load","useImperativeHandle","Header","className","to","App","intervalId","isDataLoaded","setIsDataLoaded","onTimeUpdate","video","target","onWaiting","controls","crossOrigin","onPlay","setInterval","superagent","post","send","then","res","console","log","body","catch","err","onSeeking","onLoadedData","onPause","clearInterval","src","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.ba6f19df.chunk.js","sourcesContent":["import React, { useEffect, useImperativeHandle, useRef, useState } from 'react';\nimport '@tensorflow/tfjs';\nconst blazeface = require('@tensorflow-models/blazeface');\n\nconst Canvas = React.forwardRef((props, ref) => {\n  const canvasRef = useRef(null);\n  const modelRef = useRef(null);\n  const [faces, setFaces] = useState([]);\n\n  const canvasToImage = () => canvasRef.current?.toDataURL('image/jpeg', 1.0);\n\n  const getDataFromImageData = (images) => {\n    if (images instanceof Array) {\n      return images.map(imageData => {\n        const canvas = document.createElement('canvas');\n        canvas.getContext('2d').putImageData(imageData, 0, 0);\n        return canvas.toDataURL();\n      });\n    }\n  };\n\n  const prediction = async (image) => {\n    if (!modelRef.current || !canvasRef.current || !image) return;\n\n    const returnTensors = false;\n    const predictions = await modelRef.current.estimateFaces(image, returnTensors);\n    const predictedFaces = [];\n\n    if (predictions.length > 0) {\n      for (let i = 0; i < predictions.length; i++) {\n        const [startX, startY] = predictions[i].topLeft;\n        const end = predictions[i].bottomRight;\n        const [width, height] = [end[0] - startX, end[1] - startY];\n        const context = canvasRef.current.getContext('2d');\n\n        predictedFaces.push(context.getImageData(startX, startY, width, height));\n        // Render a rectangle over each detected face.\n        context.fillStyle = 'rgb(184,22,22)';\n        context.fillRect(startX, startY, width, height);\n      }\n    }\n    setFaces(getDataFromImageData(predictedFaces));\n  };\n\n  const drawOnCanvas = async (image) => {\n    if (image) {\n      canvasRef.current\n        ?.getContext('2d')\n        ?.drawImage(image, 0, 0, canvasRef.current.width, canvasRef.current.height);\n      await prediction(image);\n    }\n  };\n\n  useEffect(() => {\n    canvasRef.current = document.createElement('canvas');\n    (async () => {\n      modelRef.current = await blazeface.load();\n    })();\n  }, []);\n\n  useImperativeHandle(ref, () => ({\n    ...canvasRef.current,\n    canvasToImage,\n    drawOnCanvas,\n    faces,\n  }));\n\n  return null;\n});\n\nexport default Canvas;\n","import React from \"react\";\r\nimport { Link } from \"react-router-dom\";\r\nimport { ROOT_ROUTE } from \"../../constants/routes\";\r\nimport \"./header.scss\";\r\n\r\nconst Header = () => (\r\n  <header className=\"header\">\r\n    <div className=\"wrapper\">\r\n      <Link to={ROOT_ROUTE}>\r\n        <h1>SHAKAL</h1>\r\n      </Link>\r\n    </div>\r\n  </header>\r\n);\r\n\r\nexport default Header;\r\n","export const ROOT_ROUTE = '/';\r\n","import { useRef, useState } from 'react';\nimport { BrowserRouter as Router } from 'react-router-dom';\nimport superagent from 'superagent';\nimport Canvas from '../canvas/canvas';\nimport Header from '../header/header';\nimport { SERVER_URL } from '../../constants/core';\nimport './App.scss';\n\nfunction App() {\n  const canvasRef = useRef(null);\n  const [isDataLoaded, setIsDataLoaded] = useState(true);\n  const SENDING_TIMESTAMP = 500;\n  let intervalId;\n\n  const onPlay = () => {\n    intervalId = setInterval(async () => {\n      if (canvasRef.current) {\n        const images = canvasRef.current?.faces;\n\n        if (images?.length) {\n          superagent\n            .post(`${SERVER_URL}/api/video`)\n            .send(images)\n            .then(res => console.log(res.body))\n            .catch(err => console.log(err));\n        }\n      }\n    }, SENDING_TIMESTAMP);\n  };\n\n  const onPause = () => clearInterval(intervalId);\n\n  const onTimeUpdate = async ({ target: video }) => {\n    if (isDataLoaded) {\n      await canvasRef.current?.drawOnCanvas(video);\n    }\n  };\n\n  const onWaiting = () => setIsDataLoaded(false);\n\n  const onLoadedData = () => setIsDataLoaded(true);\n\n  return (\n    <Router>\n      <div className=\"app\">\n        <Header />\n        <video\n          controls\n          crossOrigin='anonymous'\n          onTimeUpdate={onTimeUpdate}\n          onPlay={onPlay}\n          onWaiting={onWaiting}\n          onSeeking={onWaiting}\n          onLoadedData={onLoadedData}\n          onPause={onPause}\n          className='app__video'\n        >\n          <source src='https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/TearsOfSteel.mp4' />\n        </video>\n        <Canvas ref={canvasRef} />\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n","export const SERVER_URL = 'http://localhost:9000';\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './components/app/App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport './index.scss';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}